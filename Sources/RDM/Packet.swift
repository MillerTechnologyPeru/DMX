//
//  Packet.swift
//  
//
//  Created by Alsey Coleman Miller on 4/1/20.
//

import Foundation
import DMX

/// RDM Packet
public struct Packet: Equatable, Hashable {
    
    // MARK: - Properties
    
    /**
     This field shall contain the defined RDM START Code (SC_RDM). Controllers and Responders shall always send SC_RDM in this slot, and any packet containing a value other than SC_RDM is outside the scope of this standard.
    */
    internal var startCode: StartCode { return .rdm }
    
    /**
     This field shall contain the Sub-START Code within RDM that defines this packet structure (SC_SUB_MESSAGE). Future versions of this standard which may have additional or different packet structures would use this field to identify the packet structure being used.
     Controllers shall always send SC_SUB_MESSAGE in this slot, and Responders shall ignore any packets containing other values.
     */
    internal var version: PacketVersion { return .current } // SC_SUB_MESSAGE
    
    /**
     The Message Length value is defined as the number of slots in the RDM Packet including the START Code and excluding the Checksum. Each slot is an 8-bit value.
     The Message Length field points to the Checksum High Slot.
     */
    internal var messageLength: UInt8 { return numericCast(type(of: self).headerLength + messageData.dataLength) }
    
    internal static var headerLength: Int { return 20 }
    
    /// Destination UID
    ///
    /// The Destination UID is the UID of the target device(s).
    public let destination: DeviceUID
    
    /// Source UID
    ///
    /// The Source UID is the UID of the device originating this packet.
    public let source: DeviceUID
    
    /**
     Transaction Number (TN)
     
     The Transaction Number is an unsigned 8-bit field. Controller generated packets increment this field every time an RDM packet is transmitted. This field shall be initialized to 0 and roll over from 255 to 0.
     Responders shall reply with their Transaction Number set to the Transaction Number contained in the controller packet to which they are responding.
     The Transaction Number can be used to help match a response message to the Controllerâ€™s request.
     */
    public let transaction: TransactionNumber
    
    /**
     Port ID / Response Type
        
     This field serves different functions depending on whether the message is being generated by the controller or the responder.
     
     * For Controller generated messages (GET_COMMAND, SET_COMMAND, and DISCOVERY_COMMAND), the Port ID field shall be set in the range of 1-255 identifying the Controller Port being used, such that the combination of Source UID and Port ID will uniquely identify the controller and port where the message originated.
     
     * For Responder generated messages (GET_COMMAND_RESPONSE, SET_COMMAND_RESPONSE, and DISCOVERY_COMMAND_RESPONSE), this field is used as the Response Type field. Response Type Field usage is detailed in Section 6.3.
     
     */
    public let typeField: UInt8
    
    /**
     Message Count
     
     The message count field is used by a responder to indicate that additional data is now available for collection by a controller. This data (which might be unrelated to the current message transaction) should be collected by the controller using the GET:QUEUED_MESSAGE command.
     
     - The Message Count shall be set to 0x00 in all controller generated requests.
     
     - The Message Count shall be incremented by a responder whenever there is a new message pending collection by a controller. Thus a controller can determine, from any response, the number of queued messages pending.

     */
    public let messageCount: UInt8
    
    /**
     Sub-Device Field
     
     Sub-devices should be used in devices containing a repetitive number of similar modules, such as a dimmer rack. The Sub-Device field allows Parameter messages to be addressed to a specific module within the device to set or get properties of that module.
     The 16-bit sub-device field provides a range of 512 valid sub-devices, addressed from 1 - 512. The value of 0xFFFF is reserved as a SUB_DEVICE_ALL_CALL. A value of 0x0000 shall be used to address the root or base properties of the device that do not belong to any sub-device module.
     The Parameter ID designates which parameter on the sub-device is being addressed. The use of Sub-Devices is described further in Section 9.
     */
    public let subDevice: SubDevice
    
    /**
     Message Data Block (MDB)
     */
    public let messageData: MessageDataBlock
    
    /**
     Checksum
     */
    public private(set) var checksum: Checksum
    
    // MARK: - Initialization
    
    /// Initialize RDM Packet
    public init(destination: DeviceUID,
                source: DeviceUID,
                transaction: TransactionNumber,
                typeField: UInt8,
                messageCount: UInt8,
                subDevice: SubDevice,
                messageData: MessageDataBlock) {
        
        // initialize properties
        self.destination = destination
        self.source = source
        self.transaction = transaction
        self.typeField = typeField
        self.messageCount = messageCount
        self.subDevice = subDevice
        self.messageData = messageData
        self.checksum = 0
        
        // calculate checksum
        self.checksum = Checksum(data: dataWithoutChecksum)
    }
    
    /// Initialize RDM Packet with Message Data Block value.
    public init <T> (destination: DeviceUID,
                     source: DeviceUID,
                     transaction: TransactionNumber,
                     typeField: UInt8,
                     messageCount: UInt8,
                     subDevice: SubDevice,
                     messageData: T) where T: MessageDataBlockProtocol {
        
        let dataBlock = MessageDataBlock(
            commandClass: T.commandClass,
            parameterID: T.parameterID,
            parameterData: messageData.parameterData
        )
        
        self.init(destination: destination,
                  source: source,
                  transaction: transaction,
                  typeField: typeField,
                  messageCount: messageCount,
                  subDevice: subDevice,
                  messageData: dataBlock
        )
    }
}

// MARK: - Methods

public extension Packet {
    
    /// Validates the checksum
    var isChecksumValid: Bool {
        return checksum == Checksum(data: dataWithoutChecksum)
    }
}

// MARK: - Data

public extension Packet {
    
    /// Initialize from Data.
    init?(data: Data) {
        
        guard data.count >= Packet.headerLength + MemoryLayout<Checksum.RawValue>.size
            else { return nil }
        
        let startCodeByte = data[0]
        let version = PacketVersion(rawValue: data[1])
        let length = Int(data[2])
        
        // verify
        guard let startCode = StartCode(rawValue: startCodeByte),
            startCode == .rdm,
            version == .current,
            data.count == length + MemoryLayout<Checksum.RawValue>.size
            else { return nil }
        
        let destinationData = data.subdataNoCopy(in: 3 ..<  9)
        let sourceData = data.subdataNoCopy(in: 9 ..<  15)
        let transaction = TransactionNumber(rawValue: data[15])
        let typeField = data[16]
        let messageCount = data[17]
        let subDevice = SubDevice(rawValue: UInt16(bytes: (data[18], data[19])))
        let messageDataBytes = data.subdataNoCopy(in: 20 ..< length)
        let checksum = Checksum(rawValue: UInt16(bigEndian: UInt16(bytes: (data[length], data[length + 1]))))
        
        guard let destination = DeviceUID(data: destinationData),
            let source = DeviceUID(data: sourceData),
            let messageData = MessageDataBlock(data: messageDataBytes)
            else { return nil }
        
        self.destination = destination
        self.source = source
        self.transaction = transaction
        self.typeField = typeField
        self.messageCount = messageCount
        self.subDevice = subDevice
        self.messageData = messageData
        self.checksum = checksum
    }
    
    /// Encoded data.
    var data: Data {
        return Data(self)
    }
}

internal extension Packet {
    
    var dataWithoutChecksum: Data {
        let length = Int(messageLength)
        var data = Data(capacity: length)
        appendWithoutChecksum(&data)
        assert(data.count == length)
        return data
    }
}

// MARK: - DataConvertible

extension Packet: DataConvertible {
    
    internal func appendWithoutChecksum(_ data: inout Data) {
        data += startCode.rawValue
        data += version.rawValue
        data += messageLength
        data += destination
        data += source
        data += transaction.rawValue
        data += typeField
        data += messageCount
        data += subDevice.rawValue.bigEndian
        data += messageData
    }
    
    static func += (data: inout Data, value: Packet) {
        
        value.appendWithoutChecksum(&data)
        data += value.checksum.rawValue.bigEndian
    }
    
    var dataLength: Int {
        return Int(messageLength) + MemoryLayout<Checksum.RawValue>.size
    }
}
