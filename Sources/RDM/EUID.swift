//
//  EUID.swift
//  
//
//  Created by Jorge Loc Rubio on 4/24/20.
//

import Foundation

/**
 The Encoded Unique ID (EUID) is a 12 byte number generated by encoding the UID.
 It is used solely for devices responding to the Unique Branch Discovery `(DISC_UNIQUE_BRANCH)` message.
 
 Each byte of the UID shall be encoded into two bytes in the EUID.
 The purpose of this process is to prevent any combination of colliding EUID data from superimposing in such a way as to generate a properly framed Break – START Code sequence followed by data that some devices might interpret as NULL START Code Data.
 The response message contains the EUID as outlined in `Table 7-1`.
 
 Seven extra slots of preamble have been added to the start of the response packet to allow for in- line devices that must shorten the packet for turning around transceivers.
 If the in-line device shortens the response packet, it shall shorten by exactly one slot time.
 The controller shall be able to process response packets with 0-7 bytes of preamble.
 
 - SeeAlso: ANSI E1.20 – 2010, Page 32: Table 7-1: `DISC_UNIQUE_BRANCH` Response Packet Encoding
 */
public struct EncodedUID: Equatable, Hashable {
    
    // MARK: - Properties
    
    /// Preamble Bytes
    ///
    /// Response Preamble bytes that may be dropped by an in-line device during turn-around.
    /// Not more than one byte may be dropped by each in-line device.
    internal let preambleBytes: [UInt8]
    
    /// Separator Byte
    ///
    /// Preamble separator byte
    internal let separator: UInt8
    
    /// Encoded Manufacturer
    internal let manufacturer: UInt32
    
    /// Encoded Device
    internal let device: UInt64
    
    /// Encoded Device
    ///
    /// Checksum is the sum of the previous 12 EUID slots.
    /// The checksum is an unsigned additive sum of the 8-bit fields into a 16-bit response value.
    internal let checksum: UInt32
    
    /// Encoded UID value
    /// Encoding by bit-wise OR with `0xAA` and` 0x55`
    internal let encodedValue: (UInt8, UInt8) = (0xAA, 0x55)
    
    // MARK: - Initialization
    
    public init(uid: DeviceUID) {
        
        self.preambleBytes = [UInt8](repeating: 0xFE, count: 7)
        self.separator = 0xAA
        self.manufacturer = UInt32(bigEndian: UInt32(bytes: (
            uid.manufacturer.bigEndian.bytes.0 | encodedValue.0,
            uid.manufacturer.bigEndian.bytes.0 | encodedValue.1,
            uid.manufacturer.bigEndian.bytes.1 | encodedValue.0,
            uid.manufacturer.bigEndian.bytes.1 | encodedValue.1
        )))
        self.device = UInt64(bigEndian: UInt64(bytes: (
            uid.device.bigEndian.bytes.0 | encodedValue.0,
            uid.device.bigEndian.bytes.0 | encodedValue.1,
            uid.device.bigEndian.bytes.1 | encodedValue.0,
            uid.device.bigEndian.bytes.1 | encodedValue.1,
            uid.device.bigEndian.bytes.2 | encodedValue.0,
            uid.device.bigEndian.bytes.2 | encodedValue.1,
            uid.device.bigEndian.bytes.3 | encodedValue.0,
            uid.device.bigEndian.bytes.3 | encodedValue.1
        )))
        
        var uidData = Data()
        uidData += uid.manufacturer.bigEndian
        uidData += uid.device.bigEndian
        
        let checksum = Checksum(data: Data(uidData))
        
        self.checksum = UInt32(bigEndian: UInt32(bytes: (
            checksum.rawValue.bigEndian.bytes.0 | encodedValue.0,
            checksum.rawValue.bigEndian.bytes.0 | encodedValue.1,
            checksum.rawValue.bigEndian.bytes.1 | encodedValue.0,
            checksum.rawValue.bigEndian.bytes.1 | encodedValue.1
        )))
    }
}

// MARK: - Data

public extension EncodedUID {
    
    static var length: Int { return 24 }
    
    init?(data: Data) {
        
        guard data.count == type(of: self).length
            else { return nil }
        
        self.preambleBytes = [data[0], data[1], data[2], data[3], data[4], data[5], data[6]]
        self.separator = data[7]
        self.manufacturer = UInt32(bigEndian: UInt32(bytes: (data[8], data[9], data[10], data[11])))
        self.device = UInt64(bigEndian: UInt64(bytes: (data[12], data[13], data[14], data[15], data[16], data[17], data[18], data[19])))
        self.checksum = UInt32(bigEndian: UInt32(bytes: (data[20], data[21], data[22], data[23])))
    }
    
    var data: Data {
        return Data(self)
    }
}

// MARK: - DataConvertible

extension EncodedUID: DataConvertible {
    
    var dataLength: Int {
        return type(of: self).length
    }
    
    static func += (data: inout Data, value: Self) {
        value.preambleBytes.forEach{ data += $0 }
        data += value.separator.bigEndian
        data += value.manufacturer.bigEndian
        data += value.device.bigEndian
        data += value.checksum.bigEndian
    }
}

// MARK: - Equatable

extension EncodedUID {
    
    public static func == (lhs: EncodedUID, rhs: EncodedUID) -> Bool {
        return lhs.preambleBytes == rhs.preambleBytes
            && lhs.separator == rhs.separator
            && lhs.manufacturer == rhs.manufacturer
            && lhs.device == rhs.device
            && lhs.checksum == rhs.checksum
    }
}

// MARK: - Hashable

extension EncodedUID {
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(self.preambleBytes)
        hasher.combine(self.separator)
        hasher.combine(self.manufacturer)
        hasher.combine(self.device)
        hasher.combine(self.checksum)
    }
}

// MARK: - Decoder

public extension EncodedUID {
    
    func decodeUID() -> DeviceUID {
        
        let uidManufaturer: DeviceUID.ManufacturerCode = UInt16(bigEndian: UInt16(bytes: (
            manufacturer.bigEndian.bytes.0 & manufacturer.bigEndian.bytes.1,
            manufacturer.bigEndian.bytes.2 & manufacturer.bigEndian.bytes.3
        )))
        
        let uidDevice: DeviceUID.DeviceCode = UInt32(bigEndian: UInt32(bytes: (
            device.bigEndian.bytes.0 & device.bigEndian.bytes.1,
            device.bigEndian.bytes.2 & device.bigEndian.bytes.3,
            device.bigEndian.bytes.4 & device.bigEndian.bytes.5,
            device.bigEndian.bytes.6 & device.bigEndian.bytes.7
        )))
        
        var uidData = Data()
        uidData += uidManufaturer.bigEndian
        uidData += uidDevice.bigEndian
        
        let checksumValidator = Checksum(rawValue: UInt16(bigEndian: UInt16(bytes: (
            checksum.bigEndian.bytes.0 & checksum.bigEndian.bytes.1,
            checksum.bigEndian.bytes.2 & checksum.bigEndian.bytes.3
        ))))
        
        assert(Checksum(data: uidData) == checksumValidator)
        
        return DeviceUID(manufacturer: uidManufaturer, device: uidDevice)
    }
}
